!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).createPullRequest={})}(this,(function(e){"use strict";async function t(e,t,r,o,n){const a="100644";if("string"==typeof n)return{path:o,mode:a,content:n};const s=n.mode??a;if("utf-8"===n.encoding)return{path:o,mode:s,content:n.content};const{data:i}=await e.request("POST /repos/{owner}/{repo}/git/blobs",{owner:t,repo:r,...n});return{path:o,mode:s,sha:i.sha}}const r=Symbol("DELETE_FILE");async function o(e,o){const{octokit:n,owner:a,repo:s,ownerOrFork:i,latestCommitSha:u,latestCommitTreeSha:l}=e;let p=[];for(const e of Object.keys(o.files)){const a=o.files[e];if(a===r)try{await n.request("HEAD /repos/{owner}/{repo}/contents/:path",{owner:i,repo:s,ref:u,path:e}),p.push({path:e,mode:"100644",sha:null});continue}catch(e){continue}if("function"!=typeof a)p.push(await t(n,i,s,e,a));else{let o;try{const{data:t}=await n.request("GET /repos/{owner}/{repo}/contents/:path",{owner:i,repo:s,ref:u,path:e});if(o=await a(Object.assign(t,{exists:!0})),o===r)try{await n.request("HEAD /repos/{owner}/{repo}/contents/:path",{owner:i,repo:s,ref:u,path:e}),p.push({path:e,mode:"100644",sha:null});continue}catch(e){continue}}catch(e){if(404!==e.status)throw e;o=await a({exists:!1})}if(null==o||"symbol"==typeof o)continue;p.push(await t(n,i,s,e,o))}}if(p=p.filter(Boolean),0===p.length)return null;const{data:{sha:c}}=await n.request("POST /repos/{owner}/{repo}/git/trees",{owner:i,repo:s,base_tree:l,tree:p});return c}async function n(e,t,r){const{octokit:o,repo:n,ownerOrFork:a,latestCommitSha:s}=e,i={message:t?r.commit:"string"==typeof r.emptyCommit?r.emptyCommit:r.commit,author:r.author,committer:r.committer,tree:e.latestCommitTreeSha,parents:[s]},{data:u}=await o.request("POST /repos/{owner}/{repo}/git/commits",{owner:a,repo:n,...i,signature:r.signature?await r.signature(i):void 0});return u.sha}async function a(e,{owner:t,repo:r,title:a,body:s,base:i,head:u,createWhenEmpty:l,changes:p,draft:c=!1,labels:h=[],forceFork:w=!1,update:f=!1}){if(u===i)throw new Error('[octokit-plugin-create-pull-request] "head" cannot be the same value as "base"');const m=Array.isArray(p)?p:[p];if(0===m.length)throw new Error('[octokit-plugin-create-pull-request] "changes" cannot be an empty array');const d={octokit:e,owner:t,repo:r},{data:g,headers:y}=await e.request("GET /repos/{owner}/{repo}",{owner:t,repo:r}),b=!!y["x-oauth-scopes"];if(!g.permissions)throw new Error("[octokit-plugin-create-pull-request] Missing authentication");if(i||(i=g.default_branch),d.ownerOrFork=t,w||b&&!g.permissions.push){const o=await e.request("GET /user");(await e.request("GET /repos/{owner}/{repo}/forks",{owner:t,repo:r})).data.find((e=>e.owner&&e.owner.login===o.data.login))||await e.request("POST /repos/{owner}/{repo}/forks",{owner:t,repo:r}),d.ownerOrFork=o.data.login}const{data:[q]}=await e.request("GET /repos/{owner}/{repo}/commits",{owner:t,repo:r,sha:i,per_page:1});d.latestCommitSha=q.sha,d.latestCommitTreeSha=q.commit.tree.sha;const T=q.commit.tree.sha;for(const e of m){let t=!1;if(e.files&&Object.keys(e.files).length){const r=await o(d,e);r&&(d.latestCommitTreeSha=r,t=!0)}(t||!1!==e.emptyCommit)&&(d.latestCommitSha=await n(d,t,e))}if(T===d.latestCommitTreeSha&&!1===l)return null;const S=await e.graphql("\n    query ($owner: String!, $repo: String!, $head: String!) {\n      repository(name: $repo, owner: $owner) {\n        ref(qualifiedName: $head) {\n          associatedPullRequests(first: 1, states: OPEN) {\n            edges {\n              node {\n                id\n                number\n                url\n              }\n            }\n          }\n        }\n      }\n    }",{owner:d.ownerOrFork,repo:r,head:u}),E=!!S.repository.ref,k=S.repository.ref?.associatedPullRequests?.edges?.[0]?.node;if(k&&!f)throw new Error(`[octokit-plugin-create-pull-request] Pull request already exists: ${k.url}. Set update=true to enable updating`);E?await e.request("PATCH /repos/{owner}/{repo}/git/refs/{ref}",{owner:d.ownerOrFork,repo:r,sha:d.latestCommitSha,ref:`heads/${u}`,force:!0}):await e.request("POST /repos/{owner}/{repo}/git/refs",{owner:d.ownerOrFork,repo:r,sha:d.latestCommitSha,ref:`refs/heads/${u}`});const O={owner:t,repo:r,head:`${d.ownerOrFork}:${u}`,base:i,title:a,body:s,draft:c};let C;if(C=k?await e.request("PATCH /repos/{owner}/{repo}/pulls/{pull_number}",{pull_number:k.number,...O}):await e.request("POST /repos/{owner}/{repo}/pulls",O),h.length)try{(await e.request("POST /repos/{owner}/{repo}/issues/{number}/labels",{owner:t,repo:r,number:C.data.number,labels:h})).data.length>h.length&&e.log.warn("The pull request already contains more labels than the ones provided. This could be due to the presence of previous labels.")}catch(t){if(403===t.status)return e.log.warn("You do not have permissions to apply labels to this pull request. However, the pull request has been successfully created without the requested labels."),C;if(403!==t.status)throw t}return C}function s(e){return{createPullRequest:a.bind(null,e)}}s.VERSION="5.1.1",e.DELETE_FILE=r,e.composeCreatePullRequest=a,e.createPullRequest=s}));
